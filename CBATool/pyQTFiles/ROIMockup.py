# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'i wrote this myself lets gooo :)'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.(I don't know what I'md doing ;))

from PyQt5 import QtCore, QtGui, QtWidgets
import sqlite3
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from CBA_data_maker import *
import pandas as pd
import re

class ExtendedComboBox(QComboBox):
    '''
    This class is responsible for the searching, sorting, and filtering for the partComboBox; very important
    '''
    def __init__(self, parent=None):
        super(ExtendedComboBox, self).__init__(parent)

        self.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.setEditable(True)

        # add a filter model to filter matching items
        self.pFilterModel = QSortFilterProxyModel(self)
        self.pFilterModel.setFilterCaseSensitivity(QtCore.Qt.CaseInsensitive)
        self.pFilterModel.setSourceModel(self.model())

        # add a completer, which uses the filter model
        self.completer = QCompleter(self.pFilterModel, self)
        # always show all (filtered) completions
        self.completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)
        self.setCompleter(self.completer)

        # connect signals
        self.lineEdit().textEdited.connect(self.pFilterModel.setFilterFixedString)
        self.completer.activated.connect(self.on_completer_activated)


    # on selection of an item from the completer, select the corresponding item from combobox
    def on_completer_activated(self, text):
        if text:
            index = self.findText(text)
            self.setCurrentIndex(index)
            self.activated[str].emit(self.itemText(index))


    # on model change, update the models of the filter and completer as well
    def setModel(self, model):
        super(ExtendedComboBox, self).setModel(model)
        self.pFilterModel.setSourceModel(model)
        self.completer.setModel(self.pFilterModel)


    # on model column change, update the model column of the filter and completer as well
    def setModelColumn(self, column):
        self.completer.setCompletionColumn(column)
        self.pFilterModel.setFilterKeyColumn(column)
        super(ExtendedComboBox, self).setModelColumn(column)

'''
    The NumericDelegate, Model, and Main classes are used to generate a tablemodel in a QTableView,
    and also allow said tablemodel to be editable.
'''
class NumericDelegate(QStyledItemDelegate):
    def createEditor(self, parent, option, index):
        editor = super(NumericDelegate, self).createEditor(parent, option, index)
        if isinstance(editor, QLineEdit):
            reg_ex = QRegExp("[0-9]+.?[0-9]{,2}")
            validator = QRegExpValidator(reg_ex, editor)
            editor.setValidator(validator)
        return editor

class Model(QAbstractTableModel):
    ActivateRole = Qt.UserRole + 1

    def __init__(self, datain, headerdata, row_names, parent=None):
        super().__init__()
        self._data = datain
        '''
        Args:
            datain: a list of lists\n
            headerdata:a list of strings
        '''
        self.arraydata = datain
        self.headerdata = headerdata
        self.row_names = row_names

    def headerData(self, section, orientation, role):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return QVariant(self.headerdata[section])
        if orientation == Qt.Vertical and role == Qt.DisplayRole:
            return QVariant(self.row_names[section])
        return QVariant()

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid(): return 0
        return len(self.arraydata)

    def columnCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        if len(self.arraydata) > 0:
            return len(self.arraydata[0])
        return 0

    def flags(self, index):
        return Qt.ItemIsEditable | Qt.ItemIsEnabled | Qt.ItemIsSelectable

    def data(self, index, role):
        if not index.isValid():
            return QVariant()
        elif role != Qt.DisplayRole:
            return QVariant()
        elif role == Qt.TextAlignmentRole:
            return int(Qt.AlignCenter | Qt.AlignVCenter)
        return QVariant(self.arraydata[index.row()][index.column()])


    # 
    # def data(self, index, role):
    #     if role == Qt.DisplayRole:
    #         value = self._data.iloc[index.row(), index.column()]
    #         return str(value)
    #     elif role == Qt.TextAlignmentRole:
    #         return int(Qt.AlignCenter | Qt.AlignVCenter)



    def setData(self, index, value, role=Qt.EditRole):
        r = re.compile(r"^[0-9]\d*(\.\d+)?$")
        if role == Qt.EditRole and value != "" and 0 < index.column() < self.columnCount():
            if index.column() in (0, 1):
                self.arraydata[index.row()][index.column()] = value
                self.dataChanged.emit(index, index, (Qt.DisplayRole, ))
                return True
            else:
                if index.column() == 2:
                    if r.match(value) and (0 < float(value) <= 1):
                        self.arraydata[index.row()][index.column()] = value
                        self.dataChanged.emit(index, index, (Qt.DisplayRole, ))
                        return True
                    else:
                        if r.match(value):
                            self.arraydata[index.row()][index.column()] = value
                            self.dataChanged.emit(index, index, (Qt.DisplayRole, ))
                            return True
        return False

    def print_arraydata(self):
        print(self.arraydata)

    def insert_row(self, data, position, rows = 1):
        self.beginInsertRows(QModelIndex(), position, position + rows - 1)
        for i, e in enumerate(data):
            self.arraydata.insert(i+position, e[:])
        self.endInsertRows()
        return True

    def remove_row(self, position, rows = 1):
        self.beginRemoveRows(QModelIndex(), position, position + rows - 1)
        self.arraydata = self.arraydata[:position] + self.arraydata[position + rows:]
        self.endRemoveRows()
        return True

    def append_row(self, data):
        self.insert_row([data], self.rowCount())

class Main(QMainWindow):
    def __init__(self,parent=None):
        self.tabledata = [[1, 2, 3, 4], [11, 12, 13, 14], [21, 22, 23, 24],
                                [31, 32, 33, 34]]
        self.df = pd.DataFrame(self.tabledata)
        self.table = self.create_table()
        delegate = NumericDelegate(self.table)
        self.table.setItemDelegate(delegate)

    def create_table(self):
        tv = QTableView()

        self.df.columns = ['Year 1', 'Year 2', 'Year 3', 'Year 4']
        self.index = ['Baseline', 'Percent Decrease', '# of parts', '# of spares']
        self.df = pd.DataFrame(self.tabledata)
        tablemodel = Model(self.tabledata, self.df.columns, self.index, self)
        stylesheet  = "QHeaderView::section{Background-color:lightgrey}"
        tv.setStyleSheet(stylesheet)
        tv.setModel(tablemodel)
        tv.resizeRowsToContents()
        return tv

class Ui_Form(object):
    '''
    Creates each widget for the gui, and sets each of the widget's attributes accordingly
    '''
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1366, 768)
        self.verticalLayout = QtWidgets.QVBoxLayout(Form)
        self.verticalLayout.setObjectName("verticalLayout")

        # sets everything for the row 1
        self.row1Info = QtWidgets.QHBoxLayout()
        self.partComboBox = ExtendedComboBox()
        self.ordersSpinBox = QtWidgets.QSpinBox(Form)
        self.sparesSpinBox = QtWidgets.QSpinBox(Form)
        self.yearsSpinBox = QtWidgets.QSpinBox(Form)
        self.partLabel = QtWidgets.QLabel(Form)
        self.ordersLabel = QtWidgets.QLabel(Form)
        self.sparesLabel = QtWidgets.QLabel(Form)
        self.yearsLabel = QtWidgets.QLabel(Form)

        # changing all settings for partComboBox
        self.partComboBox.setEditable(True)
        self.partComboBox.setMaxVisibleItems(100)

        self.partComboBox.setCurrentText("{default}")

        self.row1Info.setObjectName("row1Info")
        self.partComboBox.setObjectName("partComboBox")
        self.ordersSpinBox.setObjectName("ordersSpinBox")
        self.sparesSpinBox.setObjectName("sparesSpinBox")
        self.yearsSpinBox.setObjectName("yearsSpinBox")
        self.partLabel.setObjectName("partLabel")
        self.ordersLabel.setObjectName("ordersLabel")
        self.sparesLabel.setObjectName("sparesLabel")
        self.yearsLabel.setObjectName("yearsLabel")
        self.ordersLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.sparesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.yearsLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)

        self.ordersSpinBox.setMinimum(1)
        self.ordersSpinBox.setMaximum(1000) # <-------------- THIS CAN BE SUBJECT TO CHANGE AT ANY POINT
        self.sparesSpinBox.setMaximum(10000)
        self.yearsSpinBox.setMinimum(1)
        self.yearsSpinBox.setMaximum(100)

        # since the fixed size policy is the same for all spinboxes, just need to define the policy once for all spinboxes
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.yearsSpinBox.sizePolicy().hasHeightForWidth())

        bold = QtGui.QFont()
        bold.setBold(True)
        bold.setWeight(75)
        self.partLabel.setFont(bold)
        self.ordersLabel.setFont(bold)
        self.sparesLabel.setFont(bold)
        self.yearsLabel.setFont(bold)
        self.partComboBox.setSizePolicy(sizePolicy)
        self.partLabel.setSizePolicy(sizePolicy)
        self.ordersSpinBox.setSizePolicy(sizePolicy)
        self.sparesSpinBox.setSizePolicy(sizePolicy)
        self.yearsSpinBox.setSizePolicy(sizePolicy)

        self.priceLabel = QtWidgets.QLabel(Form)
        self.learnRateSpinBox = QtWidgets.QSpinBox(Form)
        self.percentDecSpinBox = QtWidgets.QSpinBox(Form)
        self.learnRateLabel = QtWidgets.QLabel(Form)
        self.percentDecLabel = QtWidgets.QLabel(Form)
        self.priceLabel.setObjectName("priceLabel")
        self.learnRateSpinBox.setObjectName("learnRateSpinBox")
        self.percentDecSpinBox.setObjectName("percentDecSpinBox")
        self.learnRateLabel.setObjectName("learnRateLabel")
        self.percentDecLabel.setObjectName("percentDecLabel")
        self.learnRateLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.percentDecLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.learnRateSpinBox.setMinimum(1)
        self.learnRateSpinBox.setMaximum(100)
        self.percentDecSpinBox.setMaximum(100)
        self.priceLabel.setFont(bold)
        self.learnRateLabel.setFont(bold)
        self.percentDecLabel.setFont(bold)
        self.learnRateSpinBox.setSizePolicy(sizePolicy)
        self.percentDecSpinBox.setSizePolicy(sizePolicy)
        self.row1Info.addWidget(self.partLabel)
        self.row1Info.addWidget(self.partComboBox)
        self.row1Info.addWidget(self.priceLabel)
        self.verticalLayout.addLayout(self.row1Info)

        # sets everything for row 2 (EXCLUSIVELY PUSH BUTTON INPUT)
        self.pushButtonRow = QtWidgets.QHBoxLayout()
        self.pushButtonRow.setObjectName("pushButtonRow")
        self.runPushButton = QtWidgets.QPushButton(Form)
        self.resetPushButton = QtWidgets.QPushButton(Form)
        self.pdfPushButton = QtWidgets.QPushButton(Form)
        self.runPushButton.setObjectName("runPushButton")
        self.resetPushButton.setObjectName("resetPushButton")
        self.pdfPushButton.setObjectName("pdfPushButton")
        self.pushButtonRow.addWidget(self.ordersLabel)
        self.pushButtonRow.addWidget(self.ordersSpinBox)
        self.pushButtonRow.addWidget(self.sparesLabel)
        self.pushButtonRow.addWidget(self.sparesSpinBox)
        self.pushButtonRow.addWidget(self.yearsLabel)
        self.pushButtonRow.addWidget(self.yearsSpinBox)
        self.pushButtonRow.addWidget(self.learnRateLabel)
        self.pushButtonRow.addWidget(self.learnRateSpinBox)
        self.pushButtonRow.addWidget(self.percentDecLabel)
        self.pushButtonRow.addWidget(self.percentDecSpinBox)
        self.pushButtonRow.addWidget(self.runPushButton)
        self.pushButtonRow.addWidget(self.resetPushButton)
        self.pushButtonRow.addWidget(self.pdfPushButton)
        self.verticalLayout.addLayout(self.pushButtonRow)

        # sets everything for row 3 (EXCLUSIVELY THE TABLE)
        self.tableInfo = QtWidgets.QHBoxLayout()
        self.tableView = QtWidgets.QTableView()
        self.tableInfo.setObjectName("tableInfo")
        self.tableView.setObjectName("tableView")
        self.tableInfo.addWidget(self.tableView)
        self.verticalLayout.addLayout(self.tableInfo)

        self.retranslateUi(Form)
        self.resetPushButton.clicked.connect(self.setValues)
        self.runPushButton.clicked.connect(self.runClicked)
        self.runPushButton.clicked.connect(NumericDelegate)
        self.runPushButton.clicked.connect(Main)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def setValues(self, Form):
        '''
            setting values for spinboxes
            returns: None
        '''
        self.partComboBox.setCurrentText("{default}")
        self.priceLabel.setText("Part Cost: ")
        self.ordersSpinBox.setValue(1)
        self.yearsSpinBox.setValue(1)
        self.learnRateSpinBox.setValue(1)
        self.sparesSpinBox.setValue(0)
        self.percentDecSpinBox.setValue(0)
        self.tableView.setModel(None)

    def runClicked(self, Form):
        '''
            generates populated table based on spinbox values and selected part in combobox
        '''
        if self.partComboBox.currentText() == "{default}":
            return

        current_part_name = self.partComboBox.currentText()
        year_range = self.yearsSpinBox.value()
        print(year_range)
        orders_value = self.ordersSpinBox.value()
        spare_value = self.sparesSpinBox.value()
        percentDecValue = self.percentDecSpinBox.value()
        learnRateValue = self.learnRateSpinBox.value()
        totalParts = spare_value + orders_value

        current_part_data = get_cba_part_data(current_part_name)
        current_part_cost = current_part_data['part_cost'][0]

        '''
        the formulas below are what's used to calculate values to be placed in each tablemodel cell
        '''
        baseline = current_part_cost * totalParts
        trueLearnRate = baseline * (1 - learnRateValue)
        truePercentDecrease = trueLearnRate * (1 - percentDecValue)


        # calculating # of parts per year
        if totalParts >= year_range:
            temp = totalParts % year_range
            temp_2 = totalParts - temp
            temp_3 = temp_2 / year_range
            row_list = [temp_3] * year_range
            if temp:
                for x in range(temp):
                    row_list[-(x+1)] = temp_3 + 1
            print("BELOW THIS IS THE LIST THAT HAS ALL THE ORDERS GENERALLY OPTIMIZED")
            print(row_list)
        else:
            print("get good")

        print(f"current_part_cost: {current_part_cost}")
        part_cost_string = "${0:.2f}".format(current_part_cost)
        self.priceLabel.setText("Part Cost: ")
        self.priceLabel.setText(str(self.priceLabel.text() + part_cost_string))

        self.tabledata = [[1, 2, 3, 4], [11, 12, 13, 14], [21, 22, 23, 24],
                            [31, 32, 33, 34]]
        self.index = ['Baseline', 'Percent Decrease', '# of parts', '# of spares']
        self.df = pd.DataFrame(self.tabledata)
        self.df.columns = ['Year 1', 'Year 2', 'Year 3', 'Year 4']

        tablemodel = Model(self.tabledata, self.df.columns, self.index, self)
        self.tableView.setModel(tablemodel)
        stylesheet  = "QHeaderView::section{Background-color:lightgrey}"
        self.tableView.setStyleSheet(stylesheet)
        self.tableView.show()

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "ROIMockup"))

        self.partComboBox.setPlaceholderText("{default}")
        string_list = get_cba_parts_list()
        self.partComboBox.addItems(string_list)
        self.partLabel.setText("select part:")
        self.ordersLabel.setText("no. of orders:")
        self.sparesLabel.setText("no. of spares:")
        self.yearsLabel.setText("no. of years:")
        self.priceLabel.setText("Part Cost: ")
        self.learnRateLabel.setText("learn rate:")
        self.percentDecLabel.setText("percent decrease:")
        self.runPushButton.setText("RUN")
        self.resetPushButton.setText("RESET")
        self.pdfPushButton.setText("PDF")



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Form = QtWidgets.QWidget()
    ui = Ui_Form()
    ui.setupUi(Form)
    Form.show()
    sys.exit(app.exec_())
